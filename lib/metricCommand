var util = require("util");
METRIC={};

/*
  DRBD Metric Command class
*/
METRIC={};

METRIC.Command = function(args) {
  this.args = null;
  this.debugOn = false;
  this.conditionals = [];
  this.executables = [];
  this.stdin = null;
  this.buffer = "";
  if (args) { this.processArgs(args); }
};

METRIC.Command.prototype.printhelp = function() {
  console.log("Usage: stdout_generator | drbd-metric [options]");
  console.log("");
  console.log("options:\n");
  console.log("  -h           print this help info\n");
  console.log("  -v           print version information\n");
  console.log("  -d           print debugging output\n");
  process.exit();
};

METRIC.Command.prototype.printversion = function() {
  var npm = require("npm");
  npm.load([], function(er) {
    console.log("drbd-metric version: ");
    npm.commands.view([ "drbd-metric", "version" ], function(er,data) {
      process.exit();
    });
  });
};

METRIC.Command.prototype.debug = function(msg) {
  if (this.debugOn) { console.log(msg); }
};

/*
  Read /proc/drbd
*/

METRIC.Command.prototype.readproc = function() {
  var fs = require('fs');
  var drbd_data;
  console.log("about to read drbd\n");
  fs.readFile('/proc/drbd', function(err, data) {
    console.log("read before error\n");
    if (err) throw err;
    console.log("reading\n");
    console.log(data);
    drbd_data = data;
  });
  if (this.debugOn) console.log(drbd_data);
  console.log("drbd section complete\n");
  fs.writeFile('message.txt', 'Hello Node', function (err) {
    if (err) throw err;
    console.log('It\'s saved!');
  });
  process.exit();
};


/*
  Process Command line arguments to METRIC Command
*/

METRIC.Command.prototype.processArgs = function processArgs(args) {

  // copy argv to chop it up
  var a = args.slice(0);
  // turn -iH into -i -H
  // nb: don't cache length.  it may change.
  for (var i = 0; i < a.length; i ++) {
    if (a[i].charAt(0) === "-" && a[i].length > 2) {
      var arg = a[i].replace(/^-+/, "").split("").map(function (a) {
        return "-" + a;
      });
      a.splice.apply(a, [i, 1].concat(arg));
    }
  }

  while (a.length > 0) {
    var arg = a.shift();
    switch(arg) {
      case "-h": // display help and exit
        this.printhelp();
        break;
      case "-v": // display version and exit
      case "-V":
      case "--version":
        this.printversion();
        break;
      case "-d": // debug
        this.debugOn = true;
        break;
      default: // read drbd
        this.readproc();
        break;
    } 
  }
};

METRIC.Command.prototype.processInput = function() {
/*
  this.stdin = process.openStdin();
  this.stdin.setEncoding("utf8");
  this.stdin.metricC = this; // context for closure

  this.stdin.on("data", function(chunk) {
    this.metricC.buffer += chunk;
    if (this.metricC.inputIsArray) return;

    var objects = null;
    if (this.metricC.buffer.match(/\n/g) || 
        this.metricC.buffer.match(/\r\n/g) || 
        this.metricC.buffer.match(/\0/g) || 
        this.metricC.buffer.match("}{")) {
      if (this.metricC.buffer.match(/\n/g)) {
        objects = this.metricC.buffer.split("\n");
      }
      if (this.metricC.buffer.match(/\r\n/g)) {
        objects = this.metricC.buffer.split("\r\n");
      }
      if (this.metricC.buffer.match(/\0/g)) {
        objects = this.metricC.buffer.split("\0");
      }
      if (this.metricC.buffer.match("}{")) {
        objects = this.metricC.buffer.split("}{").join("}\n{").split("\n");
      }

      this.metricC.buffer = objects.pop();

      if (this.metricC.headerPassthrough) {
        for (var i = 0, l = objects.length; i < l; i ++) {
          process.stdout.write(objects[i]+"\r\n");
          if (objects[i] === "") {
            this.metricC.headerPassthrough = false;
            break;
          }
        }
        objects.splice(0, i);
      }

      if (objects.length) this.metricC.processObjects(objects);
    }
  });

  var handleEPIPE = function(e) {
    if (e.code !== "EPIPE") {
      process.emit("error", e);
    }
  };
  process.stdout.on("error", handleEPIPE);

  this.stdin.on("end", function() {
    this.metricC.processObjects([this.metricC.buffer, null]);
    process.stdout.removeListener("error", handleEPIPE);
  });
*/
};

